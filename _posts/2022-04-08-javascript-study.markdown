---
layout: post
title: "Javascript Study"
date: 2022-04-08 13:40:30 +0530
categories: Javascript NodeJS
---

<br>

# Javascript

## 기본 개념

1. Javascript란

   - 자바스크립트는 일반적으로 프로그래밍 언어로서 기본 뼈대를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 Web API, 즉 DOM, BOM, Canvas, XMLHttpRequest, Fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker 등을 아우르는 개념

2. ECMAScript
   - 자바스크립트의 표준 명세인 ECMA-262를 말하며 프로그래밍 언어의 타입, 값, 객체와 프로퍼티, 함수, 빌트인 객체 등 핵심 문법(core syntax)을 규정한다. 각 브라우저 제조사는 ECMAScript를 준수하여 브라우저에 내장되는 자바스크립트 엔진을 구현한다.
3. 특징
   - 명령형(imperative), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어.
   -
4. Node.js
   - Chrome V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경(Runtime Environment)이다. 간단히 말해 브라우저에서만 동작하던 자바스크립트를 브라우저 이외의 환경에서 동작시킬 수 있는 자바스크립트 실행 환경

## 기본 문법

1. 키워드
   - 키워드(keyword)는 수행할 동작을 규정한 것이다. 예를 들어 var 키워드는 새로운 변수를 생성할 것을 지시한다.
2. 변수

   1. 변수 선언시 사용하는 키워드

      1. var

      - ES5에서 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것
      - 함수 레벨 스코프(Function-level scope)
      - var 키워드 생략 허용
      - 중복 선언 허용
      - 변수 호이스팅
      - 스코프의 선두에서 선언 단계와 초기화 단계가 한번에 이뤄짐(선언하고, undefined로 초기화됨)

      2. const

      - 블록 레벨 스코프
      - 재할당이 금지
      - const { , } = 변수명; --> 구조 분해 할당으로 객체 분해한 것

      3. let

      - 블록 레벨 스코프
      - 재할당 자유로움
      - 중복 선언 불가
      - 선언문 이전에 참조하면 참조에러 발생(스코프 시작점 ~ 변수 선언까지 일시적 사각지대에 빠져, 변수 참조 불가)
      - 스코프의 선두에서 선언 단계가 실행되고 변수 선언문에서 초기화 단계가 실행
      - 선언 단계 초기화 단계 분리되어 진행

   2. 동적 타이핑

      - 자바스크립트는 C나 Java외는 다르게 변수를 선언할 때 데이터 타입을 미리 지정하지 않는다. 다시 말해, 변수에 할당된 값의 타입에 의해 동적으로 변수의 타입이 결정된다. 이를 동적 타이핑이라 하며 자바스크립트가 다른 프로그래밍 언어와 구별되는 특징 중 하나이다.

   3. primitive 변수 타입

      - 원시 타입은 값으로 복사되어 전달(pass by value)
      - 값이 한 번 정해지면 변경 X(immutable)
      - 런타임(변수 할당 시점)에 메모리 스택 영역에 고정된 메모리 영역을 점유하고 저장
        1. number
        - NaN : 산술 연산 불가(not-a-number) number \* string 하는 경우 발생
        2. string
        - 자바스크립트의 문자열은 원시 타입이며 변경 불가능(immutable)
        - 같은 변수에 대입해도 메모리에 대입했었던 string 값 다 남아있고, 가리키는 문자열만 달라짐
        3. undefined
        - 선언은 되었지만 값을 할당하지 않은 변수에 접근하거나 존재하지 않는 객체 프로퍼티에 접근할 경우 undefined가 반환
        - undefined는 개발자가 의도적으로 할당한 값이 아니라 자바스크립트 엔진에 의해 초기화된 값
        4. null
        - 자바스크립트는 대소문자를 구별(case-sensitive)하므로 null은 Null, NULL등과 다름
        - 의도적으로 변수에 값이 없다는 것을 명시할 때 사용
        - 자바스크립트 엔진은 누구도 참조하지 않는 메모리 영역에 대해 가비지 콜렉션을 수행
        - typeof 연산자로 null 값을 연산해 보면 null이 아닌 object가 나온다. 이는 자바스크립트의 설계상의 오류
        - null 타입을 확인할 때 typeof 연산자를 사용하면 안되고 일치 연산자(===)를 사용하여야 함
        5. symbol
        - 심볼(symbol)은 ES6에서 새롭게 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값이다. 심볼은 주로 이름의 충돌 위험이 없는 유일한 객체의 프로퍼티 키(property key)를 만들기 위해 사용한다. 심볼은 Symbol 함수를 호출해 생성한다. 이때 생성된 심볼 값은 다른 심볼 값들과 다른 유일한 심볼 값이다.

   4. 객체 변수 타입
      - 원시 타입(Primitives)을 제외한 나머지 값들(배열, 함수, 정규표현식 등)은 모두 객체
   5. 변수의 중복 선언이 가능 : 에러 없이 이전 변수 값 덮어씀

   6. 변수 호이스팅
      - 모든 선언문은 호이스팅(Hoisting)됨
      - 호이스팅이란 var 선언문이나 function 선언문 등 모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성을 말한다. 즉, 자바스크립트는 모든 선언문(var, let, const, function, function, class)이 선언되기 이전에 참조 가능하다.

3. 제어문

   - for–in 문은 객체의 프로퍼티를 순회하기 위해 사용(순서없))
   - for–of 문은 배열의 요소를 순회하기 위해 사용한다.

4. 함수

   1. 정의

   - 함수란 어떤 작업을 수행하기 위해 필요한 문(statement)들의 집합을 정의한 코드 블록
   - 함수는 이름과 매개변수를 갖으며 필요한 때에 호출하여 코드 블록에 담긴 문들을 일괄적으로 실행할 수 있다.

   2. 특징

   - 자바스크립트의 함수는 일급 객체
   - 무명의 리터럴로 표현이 가능하다.(익명 함수)
   - 변수나 자료 구조(객체, 배열…)에 저장할 수 있다.
   - 함수의 파라미터로 전달할 수 있다.
   - 반환값(return value)으로 사용할 수 있다.

   3. 함수 호이스팅

   - 함수 선언문으로 함수가 정의되기 이전에 함수 호출이 가능
   - 함수 선언문의 경우, 함수 선언의 위치와는 상관없이 코드 내 어느 곳에서든지 호출이 가능한데 이것을 함수 호이스팅(Function Hoisting)
   - 자바스크립트는 ES6의 let, const를 포함하여 모든 선언(var, let, const, function, function, class)을 호이스팅(Hoisting)한다.
   - 함수 선언문 이용 시 함수 호이스팅 발생
   - 스크립트 로딩 시점에 변수 객체에 함수 할당
   - 호이스팅이란 var 선언문이나 function 선언문 등 모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성을 말한다. 즉, 자바스크립트는 모든 선언문(var, let, const, function, function, class)이 선언되기 이전에 참조 가능하다.
   - 함수 호이스팅 != 변수호이스팅
   - var test = function(){}; 와 같은 함수 표현식이면 변수 호이스팅 발생(호이스팅시 undefined로 초기화, 실제 값 할당은 할당문에서 발생)
   - 변수 호이스팅은 runtime에 해석/실행
   - 함수 호이스팅은 함수 호출 전 반드시 함수를 선언해야한다는 규칙 무시 > 함수 표현식 사용이 권고됨

   4. 일급 객체

   - 생성, 대입, 연산, 인자 또는 반환값으로서의 전달 등 프로그래밍 언어의 기본적 조작을 제한없이 사용할 수 있는 대상
   - 무명의 리터럴로 표현이 가능하다.
   - 변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.
   - 함수의 매개변수에 전달할 수 있다.
   - 반환값으로 사용할 수 있다.
   - 위의 특징 가지면 일급 객체임

   5. 매개변수

   - 함수에 인수 전달하지 않으면 매개변수는 undefined로 초기화됨

   6. Call-by-value

   - 원시 타입 인수는 Call-by-value(값에 의한 호출)로 동작
   - 함수 호출 시 원시 타입 인수를 함수에 매개변수로 전달할 때 매개변수에 값을 복사하여 함수로 전달하는 방식
   - 함수 내에서 매개변수를 통해 값이 변경되어도 전달이 완료된 원시 타입 값은 변경되지 않는다

   7. Call-by-reference

   - 객체형(참조형) 인수는 Call-by-reference(참조에 의한 호출)로 동작
   - 함수 호출 시 참조 타입 인수를 함수에 매개변수로 전달할 때 매개변수에 값이 복사되지 않고 객체의 참조값이 매개변수에 저장되어 함수로 전달되는 방식
   - 함수 내에서 매개변수의 참조값을 이용하여 객체의 값을 변경했을 때 전달되어진 참조형의 인수값도 같이 변경

   8. return

   - 자바스크립트 해석기는 return 키워드를 만나면 함수의 실행을 중단한 후, 함수를 호출한 코드로 되돌아간다. 만일 return 키워드 이후에 다른 구문이 존재하면 그 구문은 실행되지 않는다.

   9. 프로퍼티

   - 함수는 객체이므로, 프로퍼티 가질 수 있음. 일반 객체와 다른 프로퍼티 가짐
   - arguments : 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회가능한(iterable) 유사 배열 객체(array-like object)
   - caller : 자신을 호출한 함수
   - length : 함수 정의 시 작성된 매개변수 갯수
   - name : 함수명. 익명함수이면 빈문자열을 값으로 가짐
   - \_\_ proto \_\_ :[[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티. 객체의 입장에서 자신의 부모 역할을 하는 프로토타입 객체를 가리키며 함수 객체의 경우 Function.prototype를 가리킨다
   - prototype : 함수 객체만이 소유하는 프로퍼티. 함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성한 인스턴스의 프로토타입 객체

   10. 함수의 종류

   - 즉시 실행 함수 : (functio() { .... }()); 정의와 동시에 실행되는 함수. 한번만 실행
   - 내부 함수 : 함수 내부에 정의된 함수
   - 재귀 함수 : 자기 자신을 호출하는 함수
   - 콜백 함수 : 특정 이벤트가 발생했을 때 시스템에 의해 호출되는 함수. 비동기식 처리 모델에 사용
   - 고차 함수 : 함수를 인자로 전달받거나 함수를 결과로 반환하는 함수. 인자로 받은 함수를 필요한 시점에 호출하거나 클로저를 생성하여 반환.

5. 객체

   1. 객체의 개념

   - 자바스크립트는 객체(object) 기반의 스크립트 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다. 원시 타입(Primitives)을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다.

   - 자바스크립트 객체는 키(이름)와 값으로 구성된 프로퍼티(property)의 집합이다. 프로퍼티의 값으로 자바스크립트에서 사용할 수 있는 모든 값을 사용할 수 있다. 자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다. 따라서 프로퍼티 값으로 함수를 사용할 수도 있으며 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드라 부른다.

   - 객체는 데이터를 의미하는 프로퍼티(property)와 데이터를 참조하고 조작할 수 있는 동작(behavior)을 의미하는 메소드(method)로 구성된 집합

   - 자바스크립트의 객체는 객체지향의 상속을 구현하기 위해 “프로토타입”이라고 불리는 객체의 프로퍼티와 메소드를 상속받을 수 있다. 이 프로토타입은 타 언어와 구별되는 중요한 개념이다.

   - 자바스크립트의 배열은 객체

   2. 생성자 함수

   - 형태 :

     ```
     function Person(name, gender) {
        this.name = name;
        this.gender = gender;
        this.sayHello = function(){
        console.log('Hi! My name is ' + this.name);
        };
     }
     ```

   - function(){}; << 파라미터가 없는 생성자 함수
   - 일반 함수와 구분하기 위해 함수명을 대문자로 시작하며 선언
   - 프로퍼티 또는 메소드명 앞에 기술한 this는 생성자 함수가 생성할 인스턴스(instance)를 가리킨다.
   - 프로퍼티 또는 메소드명 앞에 기술한 this는 생성자 함수가 생성할 인스턴스(instance)를 가리킨다.
   - this. 으로 선언되면 this에 바인딩되어 public한 변수(외부에서 접근 가능)
   - 생성자 함수 내에서 선언된 일반 변수는 private(외부에서 참조 불가능)하다. 즉, 생성자 함수 내부에서는 자유롭게 접근이 가능하나 외부에서 접근할 수 없다.
   - 생성자 함수가 아닌 일반 함수에 new 연산자를 붙여 호출하면 생성자 함수처럼 동작할 수 있음
   - 연산자가 들어간 표현식을 프로퍼티 키로 사용하려면 키를 대괄호로 묶어야함 like [first-name]
   - 프로퍼티는 마침표, 대괄호로 접근 가능(안의 키가 반드시 문자열이어야 함)
   - 대괄호로 접근하는 이유 : 객체의 키로 접근할 때 key에 유효한 값이 들어가지 않았을 때, 동적으로 키를 받아올때(매개변수로 받아온 값을 사용할때)
   - 생성자 함수가 생성한 객체의 메소드는 객체의 프로퍼티 뿐만 아니라, 자신이 기억하는 렉시컬 환경의 변수에도 접근할 수 있다

   3. 객체 타입 동작원리

   - 객체 타입은 변경가능(mutable)
   - 객체 타입은 동적으로 변화, 런타임에 메모리 공간 확보하고 메모리의 힙 영역에 저장
   - 원시 타입은 값으로 복사되어 전달(pass by value)
   - 객체는 참조 방식으로 전달되어 복사되지 않음(pass by reference)

   4. 객체 분류

      1. Built-in Object(내장 객체)는 웹페이지 등을 표현하기 위한 공통의 기능을 제공
         - Standard Built-in Objects (or Global Objects)
         - BOM (Browser Object Model)
         - DOM (Document Object Model)
      2. Host Object(사용자 정의 객체)

   5. 불변 데이터 패턴 (immutable data pattern)

   - 레퍼런스를 참조한 다른 객체에서 객체 변경하는 방법 > 객체를 불변객체로 만들기
   - 방법 : 1)객체의 방어적 복사(Object.assign), 2)불변객체화를 통한 객체 변경 방지(Object.freeze) 3)Immutable.js 사용

6. 동치 연산자
   1. Equality(==)
   - 연산 전에 피연산자를 형변화해서 비교
   ```
   254 == '254' //true
   ture == 1 //true
   undefined == null //true
   'abc' == new String('abc') //원시타입과 객체 비교인데 true
   null = false //false
   true == 2 // false
   ```
   2. Identitiy
   - 연산 전에 피연산자를 형변화 하지 않음

## 프로토타입

1. 개념

   - 자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다. 그리고 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 Prototype(프로토타입) 객체 또는 줄여서 Prototype(프로토타입)이라고 함

2. 프로토타입 체인

   - 자바스크립트는 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 [[Prototype]]이 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다
   - Function.prototype 는 생성자 함수의 프로토타입(약간 클래스..? 뭐 이런 느낌인가..? 싶음)
   - Function의 생성자 함수는 Function.prototype의 constructor(생성자)
   - 동작 조건 : 객체의 프로퍼티를 참조하는 경우, 해당 객체에 프로퍼티가 없는 경우, 프로토타입 체인이 동작한다.
   - 객체의 프로퍼티에 값을 할당하는 경우, 프로토타입 체인이 동작하지 않는다(자식 객체에 프로퍼티를 동적으로 추가)
   - 식별자 중에서 변수가 아닌 객체의 프로퍼티(물론 메소드도 포함된다)를 검색하는 메커니즘(변수를 검색하는 메커니즘은 스코프 체인임)

3. 원시타입

   - 원시 타입은 객체가 아니므로 프로퍼티나 메소드를 가질수 없다
   - 하지만 원시 타입으로 프로퍼티(str.constructor)나 메소드(str.toUpperCase())를 호출할 때 원시 타입과 연관된 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 된다
   - String 객체의 예 : String 객체의 프로토타입 객체인 String.prototype에 메소드를 추가하면 원시 타입, 객체 모두 메소드를 사용할 수 있음

4. Rest 파라미터

   - 매개 변수 이름 아에 세 개의 점을 붙여 정의한 매개변수
   - 함수에 전달된 인수들의 목록을 배열로 전달 받음. 먼저 선언된 파라미터에 할당된 인수를 제외한 나머지 인수들이 모두 배열로 담김.
   - 반드시 마지막 파라미터여야 함
   - 함수.length(함수의 매개변수 개수)에 영향을 주지 않음

     ```
     function bar(param1, param2, ...rest) {
        console.log(param1); // 1
        console.log(param2); // 2
        console.log(rest); // [3,4,5]
     }

     bar(1,2,3,4,5);
     ```

5. Spread 문법

   - ...으로 사용. 대상을 개별 요소로 분리. 문법의 대상이 이터러블 이어야함
   - 어느 위치에 사용 가능

     ```
     console.log(...[1,2,3]) //1,2,3으로 분리

      //es5
     function foo(x,y,z) {
        console.log(x); //1
        console.log(y); //2
        console.log(z); //3
     }

     const arr = [1,2,3];
     foo.apply(null,arr); //2번째 인수인 배열이 1,2,3으로 분해되어 foo에 전달

     //es6 spread
     function foo(x,y,z) {
        console.log(x); //1
        console.log(y); //2
        console.log(z); //3
     }

     const arr = [1,2,3];
     foo( ...arr); // 1,2,3으로 분리되어 개별적인 인자로 각각 매개변수에 전달
     foo(...[1,2,3]);

     const arr = [1,2,3];
     console.log([...arr,4,5,6]); //[1,2,3,4,5,6]

     cosnt arr = [1,2,3];
     const copy = [...arr]; //배열의 복사 가능

     const n = {x:1, y:2, ...{a:3, b:4}}; // {x:1, y:2, a:3, b:4}

     const {x,y, ...z} = n; //x=1, y=2, z = {a:3, b:4}

     //객체의 병합
     const merged = { ...{x:1, y:2}, ...{y:10, z:3} }; //{x:1, y:10, z:3}

     //특정 프로퍼티 변경
     const changed = { ...{x:1, y:2}, y:100}; //{x:1, y:100}

     //프로퍼티 추가
     const added = { ...{x:1, y:2}, z:0}; //{x:1, y:2, z:0}
     ```

## 스코프

1. 자바스크립트의 스코프
   - 함수 레벨 스코프(function-level scope)를 따름
   - let 키워드를 쓰면 블록 레벨 스코프 사용이 가능
2. 전역 스코프
   - 전역에 변수를 선언하면 이 변수는 어디서든지 참조할 수 있는 전역 스코프를 갖는 전역 변수가 된다
   - var 키워드로 선언한 전역 변수는 전역 객체(Global Object) window의 프로퍼티
   - 전역 변수의 사용은 변수 이름이 중복될 수 있고, 의도치 않은 재할당에 의한 상태 변화로 코드를 예측하기 어렵게 만드므로 사용을 억제하여야 한다
3. 비 블록 레벨 스코프
   - 함수 밖에서 선언된 변수라면, 전역 스코프를 가짐 (코드 블록 내에서 선언되어도,,,)
   ```
   if (true){
      var x = 5; //x는 전역변수임
   }
   console.log(x);
   ```
4. 함수 레벨 스코프
   - 함수 내에서 선언된 매개변수와 변수는 함수 외부에서는 유효하지 않음.
   - 함수 레벨 스코프에 있는 변수들은 지역 변수
   - 변수명이 중복된 경우 지역변수를 우선하여 참조
   - 내부 함수는 자신을 포함하고 있는 외부함수의 변수에 접근할 수 있다.
   - 함수 안에서 전역변수 참조 및 변경 가능. 내부 함수의 경우 전역 변수 상위 함수에서 선언한 변수에 접근/변경 가능
   - 중첩 스코프는 가장 인접한 지역을 우선하여 참조
5. 프로그래밍 언어에서 상위 스코프 결정 방식

   - 동적 스코프 : 함수 호출 위치에 따라 상위 스코프 결정
   - 렉시컬 스코프/정적 스코프 : 함수 선언 위치에 따라 상위 스코프 결정
   - 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다

6. 렉시컬 스코프

   - 함수를 어디에 선언하였는지에 따라 상위 스코프 결졍.

   ```
   var x = 1;

   function foo() {
      var x = 10;
      bar();
   }

   //bar는 전역에서 선언하였으므로 상위 스코프는 전역임
   function bar() {
      console.log(x);
   }

   foo();
   bar();
   ```

7. 암묵적 전역

   - 선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 된다
   - 전역 객체(window)의 프로퍼티 != 전역 변수
   - 변수가 아니므로 변수 호이스팅 발생하지 않음
   - delete 연산자로 삭제 가능 (전역변수는 delete 연산자로 삭제 불가)

   ```
   var x = 10; // 전역 변수

   function foo () {
   // 선언하지 않은 식별자
   y = 20; // 전역 객체의 프로퍼티
   console.log(x + y);
   }

   foo(); // 30
   ```

8. 전역변수 사용 최소화
   - 전역변수 객체 하나 만들기
9. 즉시실행함수를 이용한 전역변수 사용 억제
   - 즉시 실행 함수는 즉시 실행되고 전역에서 바로 사라진다

## 실행 컨텍스트

1. 실행 컨텍스트

   - 실행 컨텍스트는 실행 가능한 코드가 실행되기 위해 필요한 환경
   - 실행 가능한 코드 : 전역 코드(전역 영역 존재), eval 코드(eval 함수로 실행), 함수 코드(함수 내에 존재)
   - 실행 컨텍스트 스택 : 현재 실행 중인 컨텍스트에서, 이 컨텍스트와 관련 없는 코드가 실행되면 새로운 컨텍스트가 생성됨. 이 컨텍스트는 스택에 쌓이고 컨트롤이 이동.

2. 실행 컨텍스트의 3가지 객체
   1. VO/변수 객체
      - 변수, 매개 변수와 인수 정보, 함수 선언(함수 표현식은 제외)
      - 전역 코드 실행시 생성되는 전역 컨텍스트의 경우와 함수를 실행할 때 생성되는 함수 컨텍스트의 경우, 가리키는 객체가 다르다
      - 전역 컨텍스트 : VO는 전역객체 가리킴(전역에 선언된 전역 변수, 전역 함수를 프로퍼티로 소유)
      - 함수 컨텍스트 : VO는 AO(활성객체) 가리킴 (지역 변수, 내부 함수, 매개변수/인수 정보를 배열 형태로 담는 argument object 추가)
   2. 스코프 체인
      - 해당 전역 또는 함수가 참조할 수 있는 변수, 함수 선언 등의 정보를 담고 있는 전역 객체 또는 활성 객체 리스트
      - 실행 컨텍스트의 활성 객체(AO)를 선두로 하여 순차적으로 상위 컨텍스트의 활성 객체(AO)를 가리키며 마지막 리스트는 전역 객체(GO)를 가리킴
      - 스코프 체인은 식별자 중에서 객체(전역 객체 제외)의 프로퍼티가 아닌 식별자, 즉 변수를 검색하는 메커니즘
      - 스코프 체인의 생성과 초기화
        1. 변수 객체화
           - 스코프 체인의 초기화 종료되면 변수 객체화가 실행. VO에 프로퍼티 값을 추가하는 것
           - 순서
             1. function code이면 매개변수가 vo의 프로퍼티로, 인수가 값으로 설정
             2. 대상 코드 내의 함수 선언시 선언된 함수명이 VO의 프로퍼티로, 생성된 함수 객체가 값으로 설정(함수 호이스팅)
             3. 대상 코드 내의 변수 선언시 선언된 변수명이 VO의 프로퍼티로, undefined가 값으로 설정(함수 호이스팅)
           - 순서 세분화
             1. 함수 선언 처리
                - 선언된 함수명이 VO의 프로퍼티로, 생성된 함수 객체가 값으로 설정
                - 생성된 함수 객체는 [[Scopes]] 프로퍼티를 가짐. 함수 객체만이 소유하는 내부 프로퍼티. 함수 객체가 실행되는 환경 가리킴
                - 내부 함수의 [[Scope]] 프로퍼티는 자신의 실행 환경, 자신 포함하는 외부 함수의 실행 환경, 전역 객체 가리킴. 외부 함수의 실행 컨텍스트가 소멸해도 [[Scope]] 프로퍼티가 가리키는 외부 함수의 실행 환경은 소멸하지 않고 참조 가능 --> 클로저
                - 스코프 체인이 가리키는 VO에 이미 함수가 등록되어 있으면 함수선언식 이전에 함수 호출이 가능
                - 함수 선언식은 VO에 함수명 프로퍼티로 추가, 함수객체를 값으로 즉시 할당 --> 함수 호이스팅
                - 함수 표현식은 일반 변수의 방식을 따른다
             2. 변수 선언 처리
                - 대상 코드 내의 변수 선언시 선언된 변수명이 VO의 프로퍼티로, undefined가 값으로 설정
                - 순서 세분화
                  1. 선언 단계 : VO에 변수를 등록. 이 VO는 스코프가 참조할 수 있는 대상
                  2. 초기화 단계 : VO에 등록된 변수를 메모리에 할당. undefined로 초기화
                  3. 할당 단계 : undefined로 초기화된 변수에 실제값 할당
                - var 키워드로 선언시 선언 단계, 초기화 단계 한 번에 발생
                - 변수 선언문 이전에 변수에 접근해도 VO에 변수가 있어 undefined 반환 --> 변수 호이스팅
        2. this value 결정
           - 결정 이전에는 전여 객체를 가리키고 있고, 함수 호출 패턴에 의해 this 할당 값 결정
        3. 전역 코드 실행
           - 변수값 할당 : 코드에서 변수 표현식 마주치는 지점. VO 검색해서 변수명에 해당하는 프로퍼티가 발견되면 그 값을 전역 변수에 할당해줌 >> VO 검색결과가 없다면 전역객체의 프로퍼티 값으로 동적 생성해주는 듯
           - 전역 코드의 함수 실행 > 새로운 함수 컨텍스트 실행
             - 순서
               1. 스코프 체인의 생성과 초기화
                  - argument 프로퍼티의 초기화
                  - Variable Instantiation 실행 (변수 객체화)
                  - 프로그램이 AO에 직접 접근 불가(프로퍼티 접근은 가능)
                  - Caller(전역 컨텍스트)의 스코프 체인이 참조하는 객체가 스코프체인에 push 됨
                  - AO와 전역 객체를 순차적으로 참조하게 됨
               2. Variable Instantiation 실행
                  - 스코프 체인의 생성과 초기화에서 생성된 Activation Object를 VO로서 변수 선언 처리
               3. this value 결정이 순차적으로 실행
                  - this 할당 값은 함수 호출 패턴에 의해 결정
                  - 내부함수면 전역 객체
           - 전역 코드의 함수 안에 내부 함수가 있다면 1. 스코프 체인의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정이 순차적으로 실행

## 클로저

1. 개념

- 클로저는 함수와 그 함수가 선언됐을 때의 렉시컬 환경(Lexical environment)과의 조합이다.
- 함수 -> 외부함수에서 반환하는 내부함수
- 렉시컬 환경 -> 내부 함수가 선언됐을 때의 스코프
- 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부 함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는 함수
- 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수

2. 자유 변수

- 클로저에 의해 참조되는 외부함수의 변수

3. 관련 개념

- 렉시컬 스코핑(Lexical scoping)
  : 스코프는 스코프는 함수를 호출할 때가 아니라 함수를 어디에 선언하였는지에 따라 결정된다. 이를 렉시컬 스코핑(Lexical scoping)라 한다
- 렉시컬 환경(Lexical environment)
  : 자신이 생성될 때의 환경

4. 활용 방법
   1. 상태 유지
   - 현재 상태 기억하여 변경된 최신 상태 유지
   2. 전역변수의 사용 억제
   - 상태 변경이나 가변(mutable) 데이터를 피하고 불변성(Immutability)을 지향하는 함수형 프로그래밍에서 부수 효과(Side effect)를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이기 위해 클로저는 적극적으로 사용된다.
   3. 정보의 은닉

## 향상된 배열 조작 기능(맵 필터 리듀스)

1. 배열

   1. 프로토타입 객체 : Array.prototype
   2. 생성자 함수
      - 매개변수 1개이고 숫자인경우 매개변수로 전달된 숫자를 length 값으로 가지는 빈 배열을 생성
      - 그 외의 경우 매개변수로 전달된 값들을 요소로 가지는 배열 생성
   3. 요소 추가
      - 동적으로 요소 추가 가능 빈배열 만들고 나중에 요소 추가
      - 배열 길이는 마지막 인덱스 기준으로 산정
      - 값 할당한 인덱스만 값 들어가고, 나머지는 undefined
   4. 요소 삭제
      - delete 연산자 사용 (length 그대로)
      - splice 메소드 사용(Array.prototype.splice, splice(시작 인덱스, 삭제할 요소수), 요소 완전 삭제. length도 변경)
   5. 배열 순회

      - for in은 요소의 순서 보장x, 불필요한 프로퍼티까지 출력
      - forEach 메소드, for of 문 사용하는게 좋음

        ```
        //forEach
        arr.forEach((item,index) => console.log(index,item));

        //for of
        for(const item of arr){
           console.log(item);
        }
        ```

   6. 배열의 프로퍼티

      - length : 요소 갯수 (희소배열 : 배열 요소의 개수와 length 프로퍼티의 값이 일치하지 않는 배열, 희소 배열은 배열의 요소 개수보다 length 프로퍼티의 값이 언제나 크다.) length 프로퍼티를 작게 바꾸면 해당 요소 갯수 이후의 인덱스값 모두 삭제됨

   7. 배열의 메소드

      - isArray(arg:any) : 인수가 배열이면 true, 아니면 false
      - from : 유사 배열 객체, 이터러블 객체 변환하여 새로운 배열 생성
      - of : 전달된 인수를 요소로 갖는 배열 생성(매개변수 1개여도 배열 생성)
      - prototype.indexOf : 인덱스 검색
      - prototype.includes : es7 도입. 배열에 요소 존재 여부 확인
      - prototype.concat : 배열 합치기. 원본 배열 변경 안되고 새 배열 만들어짐
      - prototype.join : 원본 배열 문자열 반환(요소1,요소2,..) 이런식으로 반환
      - prototype.push : 배열 마지막 요소에 값 추가, 변경된 length 반환. 원본 배열 직접 변경. es6 spread 문법 사용 권장
      - prototype.pop : 마지막 요소 제거후 제거 요소 반환. 원본배열 직접 변경.
      - prototype.reverse : 배열 뒤집기. 원본 배열 변경
      - prototype.shift : 첫 요소 제거후 제거 요소 반환. 원본배열 직접 변경.
      - prototype.unshift : 배열 첫 요소에 값 추가. 원본 배열 직접 변경.
      - prototype.slice(복사 시작 인덱스, 복사 끝 인덱스) : 부분 복사. 원본배열 변경X. 얕은 복사. 유사배열 객체를 배열로 변환
      - prototype.splice : 요소 완전 삭제, splice(시작 인덱스, 삭제할 요소수, 그 자리에 추가할 새로운 요소들,,,,). 원본 배열 직접 변경.

   8. 유사 배열 객체
      ````
      var test = {
         length : 1,
         0: 1,
         1: 2
      }
      ```'
      ````
   9. 일반 배열과의 차이점
      - 일반적인 배열은 인덱스로 배열 요소에 빠르게 접근할 수 있다. 하지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 효율적이지 않다.
      - 자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근하는 경우, 일반적인 배열보다 성능적인 면에서 느릴 수 밖에 없는 구조적인 단점을 갖는다. 하지만 특정 요소를 탐색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.
   10. 배열 고차 함수

   - 고차 함수 : 함수를 인자로 전달받거나 함수를 결과로 반환하는 함수
   - prototype.sort : 정렬된 배열 반환. 원본 배열 직접 변경. quickSort 알고리즘 사용. ecmascript2019sms timsort 알고리즘 사용. 숫자타입이어도 유니코드 포인트 순서에 따라 정렬. 1 10 2 3 4 .. 일케 정렬됨

   ```
   // 숫자 배열 오름차순 정렬
   // 비교 함수의 반환값이 0보다 작으면 a 우선하여 정렬
   arr.sort( function (a,b) {return a-b;} );
   arr.sort( (a,b) => a-b ); //화살표 함수 문법

   // 숫자 배열 내림차순 정렬
   // 비교 함수의 반환값이 0보다 크면 b 우선하여 정렬
   arr.sort( function (a,b) {return b-a;} );
   arr.sort( (a,b) => b-a ); //화살표 함수 문법
   ```

   - prototype.forEach : 배열 순회, undefined 반환, 원본 배열 변경하지 않으나 콜백 함수는 원본 배열 변경이 가능. break 문을 사용할 수 없음. for 문에 비해 성능이 안좋지만 가독성이 좋음. ie 9 이상에서 정상 동작. 두번째 인자로 this를 전달할 수 있음
   - prototype.map : 배열 순회하며 각 요소에 대해 인자로 주어진 콜백 함수의 반환값으로 새로운 배열 생성하여 반환. 원본 배열 변경 X. 두번째 인자로 this를 전달할 수 있음
   - prototype.filter : if문 대체 가능. 배열 순회하며 각 요소에 대해 인자로 주어진 콜백함수 실행 결과가 true인 배열 요소의 값만 추출항 새로운 배열 반환. 특정 케이스만 필터링해 새로운 배열 만들고 싶을 때 사용. 원본 배열은 변경. 두번째 인자로 this를 전달할 수 있음. 리턴값이 1이라면 true
   - prototype.reduce : 배열을 순회하며 각 요소에 대해 이전의 콜백함수 실행 반환값을 전달. 콜백함수를 실행하고 그 결과를 반환. ie 9 이상에서 정상 동작. 두번째 인수로 초기 값을 전달할 수 있다(지정안하면 배열의 0번 인덱스 값이 초기 값인듯). 빈 배열에서 호출하면 에러 발생.

## 라우팅

1. 개념

- 출발지에서 목적지까지의 경로를 결정하는 기능
- 사용자가 요청한 url 또는 이벤트를 해석하고 새로운 페이지로 전환하기 위해 필요한 데이터를 서버에 요청하고 페이지 전환하는 행위
- 브라우저 화면 전환 케이스
  - 주소창에 url 입력
  - 웹페이지의 링크 클릭
  - 뒤로가기/앞으로가기(history 변경)

## 클래스

1.  개념

- ES6의 클래스. 일종의 함수라 볼 수 있으나 클래스, 생성자 함수는 동일하게 동작하지 않음

2. 클래스 정의

- class 키워드 사용하여 정의
- 표현식으로도 정의 가능(함수 표현식과 동일하게 클래스/함수 표현식에서 사용한 클래스/함수 일므은 외부 코드에서 접근 불가)

  ```
  class Person {
     constructor(name) {
        this._name = name; // 파스칼 케이스 사용. 사용하지 않아도 에러 발생하지 않음
     }

     sayHi() {
        console.log(`Hi! ${this._name}`);
     }
  }

  const me = new Person('Lee');
  me.sayHi();

  const Foo = class MyClass {};
  const foo = new Foo();
  new MyClass(); //Reference Error 발생
  ```

3. 클래스 특징

- 선언문 이전에 참조 불가
- let, const 키워드로 선언된 변수처럼 호이스팅되나, 클래스 선언문 이전에 일시적 사각지대에 빠져서 참조 불가

4. 인스턴스 생성

- new 연산자로 클래스 이름 호출하는 형식으로 진행
- 이때 new 연산자와 함께 호출한 Foo는 클래스의 이름이 아니라 생성자
- new 연산자를 사용하지 않으면 type error 발생

5. 클래스 필드

- 클래스 내부의 캡슐화된 변수, 데이터 멤버 또는 멤버 변수라고 부름
- 인스턴스의 프로퍼티 또는 정적 프로퍼티가 될 수 있음
- 자바스크립트의 생성자 함수에서 this에 추가한 프로퍼티를 클래스 필드라고 부름

6. constructor

- 인스턴스를 생성하고 클래스 필드를 초기화하기 위한 특수한 메소드
- 클래스 내에 한 개만 존재. 2개 이상의 constructor를 포함하면 문법 에러 발생
- 생략 가능. 생략시 constructor(){} 포함한 것처럼 동작
- 인스턴스 생성과 동시에 클래스 필드 생성,초기화 실행
- 클래스 body에는 메소드만 선언 가능. body에 클래스 필드 선언하면 문법 에러 발생 (최신 브라우저, 최신 노드에서는 에러 발생 안함)
- this와 바인딩 되는 클래스 필드는 인스턴스의 프로퍼티가 됨. 클래스 외부에서 접근 가능(public)
  ```
  class Foo {
     name = ''; //에러 발생
     constructor(){}
  }
  ```

7. getter

- 메소드 이름 앞에 get 키워드를 사용해 정의. 메소드 이름은 클래스 필드 이름처럼 사용. 반드시 무언가를 반환해야 함. 접근자 프로퍼티(프로토타입의 프로퍼티)

```
class Foo {
   constructor(arr= []){
      this._arr = arr;
   }

   get firstElem() {
      return this._arr.length ? this._arr[0] : null;
   }
}

const foo = new Foo([1,2]);

console.log(foo.firstElem); // 메소드 호출하는 것보다는.. 프로퍼티 호출하는 것 같죠? 결과값은 1임
```

8. setter

- 메소드 이름 앞에 set 키워드를 사용해 정의. 메소드 이름은 클래스 필드 이름처럼 사용. 접근자 프로퍼티(프로토타입의 프로퍼티)

```
class Foo {
      constructor(arr=[]){
         this._arr = arr;
      }

      set firtElem(elem) {
         //spread 문법 사용해서 배열 변환
         this._arr = [elem, ...this.arr];
      }
}

const foo = new Foo([1,2]);

foo.firstElem = 100; //setter 호출
```

9. 정적 메소드

- static 키워드로 정적 메소드 정의. 클래스 이름으로 호출되며, 인스턴스 생성하지 않아도 호출 가능.
- 일반 메소드의 내부에서 this는 클래스의 인스턴스를 가리킴. 정적 메소드는 인스턴스로 호출할 수 없어 this 사용 불가

```
//정적 메소드
class Foo {
   constructor(prop){
      this.prop = prop;
   }

   static staticMethod() {
      return 'staticMethod';
   }

   prototypeMethod() {
      return this.prop;
   }
}

console.log(Foo.staticMethod());
const foo = new Foo(123);
console.log(foo.prototypeMethod()); //123

//정적 메소드 호출시 에러 발생
console.log(foo.staticMethod()); //Uncaught type err : foo.staticMethod is not a function

//es5 문법

var Foo = (function(){
   function Foo(prop){
      this.prop = prop;
   }

   Foo.staticMethod = function () {
      return 'staticMethod';
   };

   Foo.prototype.prototypeMethod = function (){
      return this.prop;
   };

   return Foo;
}());

var foo = new Foo(123);
console.log(foo.prototypeMethod()); //123
console.log(Foo.staticMethod());
console.log(foo.staticMethod()); //type error 발생
```

- 함수 객체만이 가지는 prototyp 프로퍼티는 함수 객체가 생성자로 사용될 때, 이 함수를 통해 생성된 객체의 부모 역할을 하는 프로토타입 객체를 가리킴
- 생성자 함수 Foo의 prototype 프로퍼티가 가리키는 프로토타입 객체는 생성자 함수 Foo를 통해 생성되는 인스턴스 foo의 부모역할을 함
- 생성자함수 Food의 prototype 프로퍼티가 가리키는 프로토타입 객체가 갖고있는 constructor 프로퍼티는 생성자 함수 Foo를 가리킴
- 정적 메소드는 생성자 함수 Foo의 메소드이고, 일반 메소드인 prototypeMethod는 프로토타입 객체 Foo.prototype의 메소드. 그래서 인스턴스인 food에서 정적 메소드 호출 X

10. 클래스 상속

- extends 키워드 사용
- 자식 클래스의 인스턴스는 프로토타입 체인에 의해 부모클래스의 메소드 사용이 가능
- 오버라이딩(상위 클래스가 갖는 메소드 하위 클래스가 재정의) 사용 가능
- cf. 오버로딩(매개변수 타입/갯수가 다른 같은 이름 메소드 구현/호출)은 자바스크립트는 지원하지 않지만 argument 객체 사용하여 구현은 가능)
- super 키워드는 부모 클래스 참조 혹은 부모 클래스의 constructor 호출할 때 사용
- super 메소드 : 자식 클래스 constuctor 내부에서 부모 클래스 constructor 호출. 자식 클래스의 constructor에서 super()를 호출하지 않으면 this에 대한 참조 에러 발생
- super 키워드는 부모 클래스(Base Class)에 대한 참조 시에도 사용
- 자식클래스의 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체는 부모 클래스
- 자식클래스는 프로토타입 체인에 의해 부모 클래스의 정적 메소드 참조가 가능(Classname.정적메소드(), 자식클래스 정적 메소드 내부에서 부모의 정적 메소드 호출 가능)
- 자식클래스의 일반 메소드 내부에서는 부모 클래스의 정적 메소드를 호출할 수 없음(인스턴스의 프로토타입 체인으로 부모 클래스의 정적 메소드 참조 불가)

## 프로미스

1. 개념

- 비동기 처리를 위한 패턴 : 콜백 함수
- 비동기 처리를 위한 똘다른 패턴, 전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현할 수 있음

## 구조분해할당(비구조화할당)

1. 개념

- 객체나 배열을 변수로 분해할 수 있게 하는 문법

2. 배열의 비구조화 할당

   - 배열 디스트럭처링을 위해서는 할당 연산자 왼쪽에 배열 형태의 변수 리스트가 필요
   - 왼쪽의 변수 리스트와 오른쪽의 배열은 배열의 인덱스 기준으로 할당

     ```
     let [x,y,z] = [1,2,3]; //x=1, y=2, z=3
     let [x,y] = [1]; // x=1, y=undefined
     let [x,y] = [1,2,3]; //x=1, y=2
     let [x, ,z] = [1,2,3]; //x=1, z=3

     //디폴트값 지정
     let [x,y=10,z=3] = [1,2] //x=1,y=2,z=3

     //스프레드 문법
     let[x, ...y] = [1,2,3]; //x=1, y=[2,3]

     //Date 객체에서 년도,월,일 추출
     const [year, month, day] = new Date().toISOString().substring(0,10).split('-');
     ```

3. 객체의 비구조화 할당

   - 객체의 각 프로퍼티를 디스트럭처링하여 변수에 할당하려면 프로퍼티 키 사용 해야함
   - 할당 기준은 프로퍼티 키이고, 할당 연산자 왼쪽에 객체 형태의 변수 리스트 필요
   - 매개변수에서도 사용 가능

     ```
     //프로퍼티 키가 prop1(prop2)인 프로퍼티 값을 변수 p1(p2)에 할당
     const {prop1:p1, prop2: p2} = {prop1: 'a', prop2: 'b'};
     console.log(p1, p2);
     console.log({prop1:p1, prop2:p2});

     const {prop1, prop2} = {prop1: 'a', prop2: 'b'};
     console.log({prop1, prop2})l // {prop1: 'a', prop2: 'b'};

     //default value 설정
     const {prop1, prop2, prop3 = 'c'} = {prop1:'a', prop2: 'b'};
     console.log({prop1, prop2, prop3}); //{prop1: 'a', prop2: 'b', prop3: 'c'}

     //배열 고차 함수에서 활용 가능
     const todos = [
        {id:1, content: 'HTML', completed: true},
        {id:2, content: 'CSS", completed: false},
        {id:3. contebt: 'JS', compelted: false}
     ];

     //todos 배열의 요소인 객체로부터 completed 프로퍼티만을 추출
     const completedTodos = todos.filter(({completed}) => completed);
     console.log(completedTodos); //{id:1, content: 'HTML', completed: true}

     //중첩 객체에서의 사용

     const person = {
        name: 'Lee',
        address: {
           zipCode: '03068',
           city: 'Seoul'
        }
     };

     const { address : {city} } = person;

     //매개 변수 사용 케이스
     const func = ({param1, param2}) => {실행 명령어}

     const func = o => {
        var param1 = o.param1;
        var param2 = o.param2;
        실행 명령어
     }
     ```

## 동작 원리

- 관련 링크 : https://ingg.dev/js-work/

1. 자바스크립트 엔진

- 작업은 기본적으로 싱글 스레드로 처리
- 단 하나의 호출 스택 사용
- 호출 스택에 쌓인 함수나 코드를 위에서 아래로 차례차례 실행(후입선출)

2. 자바스크립트 런타임

- 자바스크립트 엔진 밖에서 자바스크립트에 관려
- Web API : 브라우저 제공 API, setTimeout HTTP 요청 메소드, DOM 이벤트 등의 메소드 지원
- Task Queue : 이벤트 발생 후 호출되어야 할 콜백 함수가 기다리는 공간. 이벤트 루프가 정한 순서대로 줄서있음. 콜백 큐
- 이벤트 루프 : 이벤트 발생 시 호출할 콜백 함수들 관리. 호출된 콜백 함수의 실행 순서 결정

3. Task Queue

- 자바스크립트에서 비동기로 호출되는 함수들은 호출 스택에 쌓이지 않고 테스트 큐에 보내짐
  ```
  console.log("A");
  setTimeout(function(){
     console.log("B");
  },0);
  console.log("C");
  // A C B 순으로 콘솔 출력
  // setTimeout 함수는 인수로 받은 콜백 함수를 일정 시간이 지난후 실행하도록 예약하는 처리만 진행. 바로 그 다음 코드가 실행
  ```

4. 비동기적 자바스크립트

- 비동기처리란 특정 코드가 종료되지 않았어도 대기하지 않고 다음 코드를 실행하는 자바스크립트의 특성
- 이벤트 루프는 call stack이 비어있을 때만 task queue의 함수를 call stack 으로 가져옴
- settimeout(function, 3000); 콜스택에 함수들이 많이 있으면 3초 후 실행이 안될 수 있음, settimeout 시간이 정확하지 않을 수 있음

5. 콜백 함수

- 실행 순서가 중요한 상황에서는 콜백함수를 중첩하여 사용
- 콜백 함수는 다른 함수에 인수로 넘겨지는 함수
- 함수의 실행이 끝나면 콜백함수 실행해주도록 요청 가능
- 콜백 함수가 중첩되면 코드 이해가 어려워짐. 프로미스를 이용해 콜백 헬 극복 및 비동기 처리 간결한 작성 가능
- 프로미스, sync/await 문법으로 비동기처리를 간결하게 진행 가능

```
function first(callback) {
   setTimeout(function(){
      console.log("첫번째");
      callback();
   }, 3000);
}

function second() {
   console.log("두번째");
}

firt(funciton(){
   second();
});

//3초 후 첫번째 출력 그 후 두번째 출력
```

6. 프로미스
